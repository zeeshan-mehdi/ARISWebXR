<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>WebXR BPMN MR POC (three.js)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="./style.css" />
</head>
<body>
  <div id="info">
    <div style="font-weight:700">WebXR BPMN MR — Quest 3 POC</div>
    <div style="font-size:12px">Tap to place panel on table. Pinch with hands to grab & move nodes/panel.</div>
  </div>
  <button id="enter-ar-btn" style="position:fixed;top:16px;right:16px;z-index:10;padding:8px 16px;font-size:16px;border-radius:6px;background:#222;color:#fff;border:none;cursor:pointer;">Enter AR</button>

  <script type="module">
  const repoName ="ARISWebXR";


  import * as THREE from './js/three.module.js';
  import { ARButton } from './js/ARButton.js';
  import { OrbitControls } from './js/OrbitControls.js';
  import { createBPMNPanel, updateArrowPositions } from './js/BPMNPanel.js';


  let camera, scene, renderer;
  let controller, controller2;
  let hand1, hand2; // Hand tracking
  let reticle = null;
  let hitTestSource = null;
  let hitTestSourceRequested = false;
  let anchorObjects = []; // keep anchors if created
  let bpmnPanel = null;
  let tempMatrix = new THREE.Matrix4();
  let raycaster = new THREE.Raycaster();
  const pointer = new THREE.Vector2();
  // Dragging state for desktop drag support
  let dragging = false, dragOffset = null;

  // Grab interaction state
  let grabbedObject = null;
  let grabbingController = null;
  let grabOffset = new THREE.Vector3();
  let grabRotation = new THREE.Quaternion();
  let isPinching = false;

  init();
  animate();

  // Always show ARButton when 'Enter AR' is clicked
  const enterARBtn = document.getElementById('enter-ar-btn');
  let arButton = null;
  enterARBtn.addEventListener('click', () => {
    if (arButton) {
      arButton.style.display = '';
      arButton.textContent = 'START AR Now';
    } else {
      arButton = ARButton.createButton(renderer, {
        requiredFeatures: [ 'hit-test', 'local-floor' ],
        optionalFeatures: [ 'anchors', 'dom-overlay', 'hand-tracking', 'layers' ],
        domOverlay: { root: document.body }
      });
      document.body.appendChild(arButton);
    }
  });

  function init() {
    // basic scene
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);

    // light
    const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
    scene.add(light);

    // renderer
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // AR button - request immersive-ar with hit-test, hand-tracking, and local-floor
    document.body.appendChild(ARButton.createButton(renderer, {
      requiredFeatures: [ 'hit-test', 'local-floor' ],
      optionalFeatures: [ 'anchors', 'dom-overlay', 'hand-tracking', 'layers' ],
      domOverlay: { root: document.body }
    }));

    // Reticle for placement
    const geometry = new THREE.RingGeometry(0.08, 0.10, 32).rotateX(-Math.PI / 2);
    const material = new THREE.MeshBasicMaterial({ color: 0x00FF88, opacity: 0.9, transparent: true });
    reticle = new THREE.Mesh(geometry, material);
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);

    // controller for select (trigger/tap) and grab (squeeze/grip)
    controller = renderer.xr.getController(0);
    controller.addEventListener('select', onSelect);
    controller.addEventListener('squeezestart', onSqueezeStart);
    controller.addEventListener('squeezeend', onSqueezeEnd);
    scene.add(controller);

    // Second controller for two-handed manipulation
    controller2 = renderer.xr.getController(1);
    controller2.addEventListener('select', onSelect);
    controller2.addEventListener('squeezestart', onSqueezeStart);
    controller2.addEventListener('squeezeend', onSqueezeEnd);
    scene.add(controller2);

    // also show a simple cursor for pointer selection in AR
    const cursorGeom = new THREE.SphereGeometry(0.01, 8, 8);
    const cursorMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
    const cursor = new THREE.Mesh(cursorGeom, cursorMat);
    controller.add(cursor);

    const cursor2 = new THREE.Mesh(cursorGeom.clone(), cursorMat.clone());
    controller2.add(cursor2);

    // Hand tracking for direct hand interactions (Quest 3)
    hand1 = renderer.xr.getHand(0);
    hand1.addEventListener('pinchstart', onPinchStart);
    hand1.addEventListener('pinchend', onPinchEnd);
    scene.add(hand1);

    hand2 = renderer.xr.getHand(1);
    hand2.addEventListener('pinchstart', onPinchStart);
    hand2.addEventListener('pinchend', onPinchEnd);
    scene.add(hand2);

    window.addEventListener('resize', onWindowResize);

    // Optional: allow desktop testing with OrbitControls (non-XR)
    const controls = new OrbitControls(camera, renderer.domElement);
    camera.position.set(0,1.6,0);
    controls.target.set(0,1.6,-1);
    controls.update();

  // Build BPMN panel but keep it hidden until placement
    bpmnPanel = createBPMNPanel();
    bpmnPanel.visible = false;
    // Rotate panel to lie flat on table (rotate 90 degrees around X axis)
    bpmnPanel.rotation.x = -Math.PI / 2;
    scene.add(bpmnPanel);
}

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  // called when user taps/selects to place panel or interact
  async function onSelect() {
    const session = renderer.xr.getSession();
    if (!session) return;

    // If reticle visible -> place or toggle selection
    if (reticle.visible) {
      // If panel is not yet placed -> create anchor (if possible) and place it
      if (!bpmnPanel.visible) {
        // try to create an anchor from the reticle's matrix
        try {
          // WebXR: if hitTest gave an XRHitTestResult with createAnchor, that would be used.
          // As fallback, create anchor from current transform using XRSession.requestAnimationFrame pose.
          const viewerRefSpace = await session.requestReferenceSpace('local');
          // Try XRAnchor via three.js helper - not standardized in three.js directly, so use session.requestAnchor if available
          if (session.requestAnchor) {
            // Some runtimes provide session.requestAnchor({space: viewerRefSpace}) - optional and experimental.
            // We'll instead attempt to use the hit test createAnchor if available via last frame results
          }
        } catch (err) {
          console.warn('Anchor attempt failed (will place without persistent anchor):', err);
        }

        // place panel at reticle position, lying flat
        const reticlePos = new THREE.Vector3();
        const reticleQuat = new THREE.Quaternion();
        const reticleScale = new THREE.Vector3();
        reticle.matrix.decompose(reticlePos, reticleQuat, reticleScale);

        bpmnPanel.position.copy(reticlePos);
        // Keep the panel lying flat (don't copy rotation from reticle)
        // Just rotate to lie flat on surface
        bpmnPanel.rotation.x = -Math.PI / 2;
        bpmnPanel.rotation.y = 0;
        bpmnPanel.rotation.z = 0;
        bpmnPanel.visible = true;
        // slightly offset upward so it's on top of surface
        bpmnPanel.position.y += 0.02;
      } else {
        // panel exists — perform selection test: raycast from controller into panel
        // compute controller world ray
        const controllerGrip = controller;
        const origin = new THREE.Vector3();
        const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(controller.gripped ? controller.gripped.quaternion : controller.quaternion);
        controller.getWorldPosition(origin);
        controller.getWorldQuaternion(tempQuat = new THREE.Quaternion());

        // simpler approach: cast ray from controller forward
        const worldPos = new THREE.Vector3();
        const worldDir = new THREE.Vector3(0, 0, -1);
        controller.getWorldPosition(worldPos);
        controller.getWorldQuaternion(tempQuat = new THREE.Quaternion());
        worldDir.applyQuaternion(tempQuat);

        raycaster.set(worldPos, worldDir);
        // find intersections with panel children (the cards)
        const intersects = raycaster.intersectObjects(bpmnPanel.children, true);
        if (intersects.length) {
          const hit = intersects[0].object;
          // find the node parent if needed
          let node = hit;
          while (node && node.parent !== bpmnPanel) node = node.parent;
          if (node && node.userData && node.userData.label) {
            highlightNode(node);
          }
        }
      }
    }
  }

  function highlightNode(node) {
    // flash the node by scaling and changing opacity slightly
    node.scale.set(1.07, 1.07, 1.07);
    setTimeout(() => node.scale.set(1,1,1), 200);
    console.log('Selected node:', node.userData.label);
    // visual feedback: add small ring behind it
    const ring = new THREE.Mesh(new THREE.RingGeometry(0.065, 0.075, 16).rotateX(Math.PI/2), new THREE.MeshBasicMaterial({ color: 0xffcc00, transparent: true, opacity: 0.9 }));
    ring.position.set(0,0,-0.01);
    node.add(ring);
    setTimeout(() => node.remove(ring), 600);
  }

  // Pinch handlers for hand tracking (Quest 3 direct hand interaction)
  function onPinchStart(event) {
    if (!bpmnPanel || !bpmnPanel.visible) return;

    const hand = event.target;
    isPinching = true;

    // Get hand position (pinch point)
    const handPos = new THREE.Vector3();
    hand.getWorldPosition(handPos);

    // Check what's near the hand (within grabbing distance)
    const grabRadius = 0.1; // 10cm grab radius

    // Check each node
    let closestNode = null;
    let closestDist = grabRadius;

    bpmnPanel.children.forEach(child => {
      if (child.userData && child.userData.label) {
        const nodeWorldPos = new THREE.Vector3();
        child.getWorldPosition(nodeWorldPos);
        const dist = handPos.distanceTo(nodeWorldPos);

        if (dist < closestDist) {
          closestNode = child;
          closestDist = dist;
        }
      }
    });

    if (closestNode) {
      // Grab the node
      grabbedObject = closestNode;
      grabbingController = hand;

      const objectWorldPos = new THREE.Vector3();
      closestNode.getWorldPosition(objectWorldPos);
      grabOffset.subVectors(objectWorldPos, handPos);

      // Visual feedback
      closestNode.children.forEach(child => {
        if (child.material && child.material.color) {
          child.userData.originalColor = child.material.color.getHex();
          child.material.color.lerp(new THREE.Color(0xffffff), 0.3);
        }
      });

      console.log('Hand grabbed node:', closestNode.userData.label);
    } else {
      // Check if hand is over panel
      const panelWorldPos = new THREE.Vector3();
      bpmnPanel.getWorldPosition(panelWorldPos);
      const distToPanel = handPos.distanceTo(panelWorldPos);

      if (distToPanel < 0.5) { // 50cm to grab whole panel
        grabbedObject = bpmnPanel;
        grabbingController = hand;
        grabOffset.subVectors(panelWorldPos, handPos);
        console.log('Hand grabbed entire panel');
      }
    }
  }

  function onPinchEnd(event) {
    if (grabbedObject && grabbingController === event.target) {
      // Restore colors
      grabbedObject.children.forEach(child => {
        if (child.material && child.userData.originalColor !== undefined) {
          child.material.color.setHex(child.userData.originalColor);
        }
      });

      console.log('Hand released:', grabbedObject.userData ? grabbedObject.userData.label : 'BPMN panel');
      grabbedObject = null;
      grabbingController = null;
      isPinching = false;
    }
  }

  // Grab/Squeeze handlers for moving objects (controller-based)
  function onSqueezeStart(event) {
    if (!bpmnPanel || !bpmnPanel.visible) return;

    const controllerSource = event.target;

    // Raycast from controller to find what we're grabbing
    const worldPos = new THREE.Vector3();
    const worldDir = new THREE.Vector3(0, 0, -1);
    const tempQuat = new THREE.Quaternion();

    controllerSource.getWorldPosition(worldPos);
    controllerSource.getWorldQuaternion(tempQuat);
    worldDir.applyQuaternion(tempQuat);

    raycaster.set(worldPos, worldDir);

    // First check if we're grabbing individual nodes
    const nodeIntersects = raycaster.intersectObjects(bpmnPanel.children, true);

    if (nodeIntersects.length > 0) {
      // Find the node parent (task/event)
      let node = nodeIntersects[0].object;
      while (node && node.parent !== bpmnPanel) node = node.parent;

      if (node && node.userData && node.userData.label) {
        // Grab individual node
        grabbedObject = node;
        grabbingController = controllerSource;

        // Calculate offset from controller to object
        const objectWorldPos = new THREE.Vector3();
        node.getWorldPosition(objectWorldPos);
        grabOffset.subVectors(objectWorldPos, worldPos);

        // Visual feedback - brighten the grabbed object
        if (node.material) {
          node.userData.originalEmissive = node.material.emissive ? node.material.emissive.getHex() : 0x000000;
          node.material.emissive = new THREE.Color(0x44ff44);
        }
        node.children.forEach(child => {
          if (child.material && child.material.color) {
            child.userData.originalColor = child.material.color.getHex();
            child.material.color.lerp(new THREE.Color(0xffffff), 0.3);
          }
        });

        console.log('Grabbed node:', node.userData.label);
        return;
      }
    }

    // If we didn't grab a node, check if we're grabbing the panel itself
    const panelIntersects = raycaster.intersectObject(bpmnPanel, true);
    if (panelIntersects.length > 0) {
      // Grab entire panel
      grabbedObject = bpmnPanel;
      grabbingController = controllerSource;

      const panelWorldPos = new THREE.Vector3();
      bpmnPanel.getWorldPosition(panelWorldPos);
      grabOffset.subVectors(panelWorldPos, worldPos);

      bpmnPanel.getWorldQuaternion(grabRotation);

      console.log('Grabbed entire BPMN panel');
    }
  }

  function onSqueezeEnd(event) {
    if (grabbedObject && grabbingController === event.target) {
      // Restore original colors
      if (grabbedObject.material && grabbedObject.userData.originalEmissive !== undefined) {
        grabbedObject.material.emissive = new THREE.Color(grabbedObject.userData.originalEmissive);
      }
      grabbedObject.children.forEach(child => {
        if (child.material && child.userData.originalColor !== undefined) {
          child.material.color.setHex(child.userData.originalColor);
        }
      });

      console.log('Released:', grabbedObject.userData ? grabbedObject.userData.label : 'BPMN panel');
      grabbedObject = null;
      grabbingController = null;
    }
  }

  // Update grabbed object position during animation loop
  function updateGrabbedObject() {
    if (grabbedObject && grabbingController) {
      const controllerWorldPos = new THREE.Vector3();
      const controllerWorldQuat = new THREE.Quaternion();

      grabbingController.getWorldPosition(controllerWorldPos);
      grabbingController.getWorldQuaternion(controllerWorldQuat);

      // Calculate new position with offset
      const newPos = new THREE.Vector3().copy(controllerWorldPos).add(
        grabOffset.clone().applyQuaternion(controllerWorldQuat)
      );

      if (grabbedObject === bpmnPanel) {
        // Move entire panel
        bpmnPanel.position.copy(newPos);
      } else {
        // Move individual node (relative to panel)
        const panelWorldMatrix = new THREE.Matrix4();
        bpmnPanel.matrixWorld.decompose(
          new THREE.Vector3(),
          new THREE.Quaternion(),
          new THREE.Vector3()
        );

        // Convert world position to panel-local position
        const panelInverseMatrix = new THREE.Matrix4().copy(bpmnPanel.matrixWorld).invert();
        const localPos = newPos.clone().applyMatrix4(panelInverseMatrix);

        grabbedObject.position.copy(localPos);
      }
    }
  }

  // animation loop
  function animate() {
    renderer.setAnimationLoop(render);
  }


  // utilities
  let lastFrame = null;
  async function render(timestamp, xrFrame) {
    // XR frame handling: hit-test & reticle
    const session = renderer.xr.getSession();
    if (session && !hitTestSourceRequested) {
      const viewerSpace = await session.requestReferenceSpace('viewer');
      if (session.requestHitTestSource) {
        session.requestHitTestSource({ space: viewerSpace }).then(source => {
          hitTestSource = source;
        });
      }
      // optional: request anchors support - many runtimes support XRAnchor on hit results via createAnchor()
      session.addEventListener('end', () => {
        hitTestSourceRequested = false;
        hitTestSource = null;
      });
      hitTestSourceRequested = true;
    }

    if (hitTestSource && xrFrame) {
      const referenceSpace = renderer.xr.getReferenceSpace();
      const hitTestResults = xrFrame.getHitTestResults(hitTestSource);
      if (hitTestResults.length > 0) {
        const hit = hitTestResults[0];
        const pose = hit.getPose(referenceSpace);
        if (pose) {
          reticle.visible = true;
          reticle.matrix.fromArray(pose.transform.matrix);
        } else {
          reticle.visible = false;
        }
      } else {
        reticle.visible = false;
      }
    }

    // Update grabbed object position
    updateGrabbedObject();

    // Update arrow positions if nodes have been moved
    if (bpmnPanel && bpmnPanel.visible) {
      updateArrowPositions(bpmnPanel);
    }

    renderer.render(scene, camera);
  }
  </script>
</body>
</html>