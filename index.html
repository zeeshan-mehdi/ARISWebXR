<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>WebXR BPMN MR POC (three.js)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; background:#000; color:#fff; font-family: Arial, Helvetica, sans-serif; }
    #info { position: absolute; left: 12px; top: 12px; z-index: 2; background: rgba(0,0,0,0.4); padding: 8px 12px; border-radius:6px; }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="info">
    <div style="font-weight:700">WebXR BPMN MR — Quest 3 POC</div>
    <div style="font-size:12px">Tap to place the panel. Point & pull trigger / tap node to select.</div>
  </div>
  <button id="enter-ar-btn" style="position:fixed;top:16px;right:16px;z-index:10;padding:8px 16px;font-size:16px;border-radius:6px;background:#222;color:#fff;border:none;cursor:pointer;">Enter AR</button>

  <script type="module">
  const repoName ="ARISWebXR";


  import * as THREE from './js/three.module.js';
  import { ARButton } from './js/ARButton.js';
  import { OrbitControls } from './js/OrbitControls.js';


  let camera, scene, renderer;
  let controller;
  let reticle = null;
  let hitTestSource = null;
  let hitTestSourceRequested = false;
  let anchorObjects = []; // keep anchors if created
  let bpmnPanel = null;
  let tempMatrix = new THREE.Matrix4();
  let raycaster = new THREE.Raycaster();
  const pointer = new THREE.Vector2();

  init();
  animate();

  // Always show ARButton when 'Enter AR' is clicked
  const enterARBtn = document.getElementById('enter-ar-btn');
  let arButton = null;
  enterARBtn.addEventListener('click', () => {
    if (arButton) {
      arButton.style.display = '';
      arButton.textContent = 'START AR';
    } else {
      arButton = ARButton.createButton(renderer, {
        requiredFeatures: [ 'hit-test', 'anchors' ],
        optionalFeatures: [ 'dom-overlay', 'hand-tracking', 'layers' ],
        domOverlay: { root: document.body }
      });
      document.body.appendChild(arButton);
    }
  });

  function init() {
    // basic scene
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);

    // light
    const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
    scene.add(light);

    // renderer
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // AR button - request immersive-ar with hit-test & anchors
    document.body.appendChild(ARButton.createButton(renderer, {
      requiredFeatures: [ 'hit-test', 'anchors' ],
      optionalFeatures: [ 'dom-overlay', 'hand-tracking', 'layers' ],
      domOverlay: { root: document.body }
    }));

    // Reticle for placement
    const geometry = new THREE.RingGeometry(0.08, 0.10, 32).rotateX(-Math.PI / 2);
    const material = new THREE.MeshBasicMaterial({ color: 0x00FF88, opacity: 0.9, transparent: true });
    reticle = new THREE.Mesh(geometry, material);
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);

    // controller for select (trigger/tap)
    controller = renderer.xr.getController(0);
    controller.addEventListener('select', onSelect);
    scene.add(controller);

    // also show a simple cursor for pointer selection in AR
    const cursorGeom = new THREE.SphereGeometry(0.01, 8, 8);
    const cursorMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
    const cursor = new THREE.Mesh(cursorGeom, cursorMat);
    controller.add(cursor);

    window.addEventListener('resize', onWindowResize);

    // Optional: allow desktop testing with OrbitControls (non-XR)
    const controls = new OrbitControls(camera, renderer.domElement);
    camera.position.set(0,1.6,0);
    controls.target.set(0,1.6,-1);
    controls.update();

  // Build a simple panel prefab and show it immediately
    bpmnPanel = createBPMNPanel();
    bpmnPanel.visible = true;
    // Place panel at eye level in front of camera
    bpmnPanel.position.set(0, 1.2, -1.2);
    bpmnPanel.lookAt(new THREE.Vector3(0, 1.2, 0));
    scene.add(bpmnPanel);

    // Desktop drag support
    let dragging = false, dragOffset = null;
    renderer.domElement.addEventListener('pointerdown', (e) => {
      if (!renderer.xr.isPresenting && bpmnPanel.visible) {
        const rect = renderer.domElement.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera({x, y}, camera);
        const intersects = raycaster.intersectObject(bpmnPanel, true);
        if (intersects.length) {
          dragging = true;
          dragOffset = intersects[0].point.sub(bpmnPanel.position);
        }
      }
    });
    renderer.domElement.addEventListener('pointerup', () => { dragging = false; });
    renderer.domElement.addEventListener('pointermove', (e) => {
      if (dragging && !renderer.xr.isPresenting) {
        const rect = renderer.domElement.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera({x, y}, camera);
        const plane = new THREE.Plane(new THREE.Vector3(0,0,1), bpmnPanel.position.z);
        const intersect = new THREE.Vector3();
        raycaster.ray.intersectPlane(plane, intersect);
        if (intersect) {
          bpmnPanel.position.x = intersect.x - (dragOffset ? dragOffset.x : 0);
          bpmnPanel.position.y = intersect.y - (dragOffset ? dragOffset.y : 0);
        }
      }
    });
  }

  // Create a simple BPMN-like panel: a thin plane + 3 nodes with text
  function createBPMNPanel() {
    const group = new THREE.Group();

  // Panel backing removed for full transparency

    // Title (canvas texture)
    const titleTex = textTexture('Simple BPMN Process', 520, 64, 24, 'center');
    const titleMat = new THREE.MeshBasicMaterial({ map: titleTex, transparent: true });
    const titleQuad = new THREE.Mesh(new THREE.PlaneGeometry(1.4, 0.12), titleMat);
    titleQuad.position.set(0, 0.26, 0.001);
    group.add(titleQuad);

    // Define process nodes: Start, 3 Tasks, End
    const nodes = [
      { id: 'start', label: 'Start', type: 'event' },
      { id: 't1', label: 'Receive Order', type: 'task' },
      { id: 't2', label: 'Check Stock', type: 'task' },
      { id: 't3', label: 'Send Confirmation', type: 'task' },
      { id: 'end', label: 'End', type: 'event' }
    ];

    const startX = -0.64;
    nodes.forEach((n, i) => {
      let card;
      if (n.type === 'event') {
        card = createEventNode(n.label, n.id === 'start' ? 0x00ff88 : 0xff4444);
      } else {
        card = createTaskNode(n.label);
      }
      card.position.set(startX + i * 0.32, 0, 0.01);
      card.userData = { id: n.id, label: n.label, type: n.type };
      group.add(card);
      // Add arrow between nodes except after last
      if (i < nodes.length - 1) {
        const arrow = createArrow();
        arrow.position.set(startX + i * 0.32 + 0.16, 0, 0.011);
        group.add(arrow);
      }
    });

    // small instruction text
    const instrTex = textTexture('Tap nodes to select', 520, 48, 16, 'center');
    const instrMat = new THREE.MeshBasicMaterial({ map: instrTex, transparent: true });
    const instrQuad = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 0.08), instrMat);
    instrQuad.position.set(0, -0.28, 0.001);
    group.add(instrQuad);

    // make group face the user by default
    group.lookAt(new THREE.Vector3(0,1.6,0));

    return group;
  }

  // Task node: rounded rectangle + label
  function createTaskNode(text) {
  const tex = textTexture(text, 256, 128, 18, 'center');
  // Aesthetic task: blue background, white border, drop shadow
  const shape = new THREE.Shape();
  const w = 0.28, h = 0.16, r = 0.04;
  shape.moveTo(-w/2 + r, -h/2);
  shape.lineTo(w/2 - r, -h/2);
  shape.quadraticCurveTo(w/2, -h/2, w/2, -h/2 + r);
  shape.lineTo(w/2, h/2 - r);
  shape.quadraticCurveTo(w/2, h/2, w/2 - r, h/2);
  shape.lineTo(-w/2 + r, h/2);
  shape.quadraticCurveTo(-w/2, h/2, -w/2, h/2 - r);
  shape.lineTo(-w/2, -h/2 + r);
  shape.quadraticCurveTo(-w/2, -h/2, -w/2 + r, -h/2);
  const geo = new THREE.ShapeGeometry(shape);
  // Main task body
  const bodyMat = new THREE.MeshBasicMaterial({ color: 0x2196f3, opacity: 0.95, transparent: true });
  const body = new THREE.Mesh(geo, bodyMat);
  // White border
  const borderMat = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.9, transparent: true });
  const border = new THREE.Mesh(geo.clone(), borderMat);
  border.scale.set(1.04, 1.08, 1);
  border.position.set(0,0,-0.002);
  body.add(border);
  // Drop shadow
  const shadowMat = new THREE.MeshBasicMaterial({ color: 0x000000, opacity: 0.18, transparent: true });
  const shadow = new THREE.Mesh(geo.clone(), shadowMat);
  shadow.scale.set(1.08, 1.12, 1);
  shadow.position.set(0,-0.01,-0.003);
  body.add(shadow);
  // Text label
  const labelMat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
  const label = new THREE.Mesh(new THREE.PlaneGeometry(0.22, 0.07), labelMat);
  label.position.set(0,0,0.004);
  body.add(label);
  return body;
  }

  // Event node: circle + label
  function createEventNode(text, color=0x00ff88) {
  const group = new THREE.Group();
  // Main event circle
  const circleGeo = new THREE.CircleGeometry(0.09, 32);
  const circleMat = new THREE.MeshBasicMaterial({ color, opacity:0.95, transparent:true });
  const circle = new THREE.Mesh(circleGeo, circleMat);
  group.add(circle);
  // White border
  const borderMat = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.9, transparent: true });
  const border = new THREE.Mesh(circleGeo.clone(), borderMat);
  border.scale.set(1.08, 1.08, 1);
  border.position.set(0,0,-0.002);
  group.add(border);
  // Drop shadow
  const shadowMat = new THREE.MeshBasicMaterial({ color: 0x000000, opacity: 0.18, transparent: true });
  const shadow = new THREE.Mesh(circleGeo.clone(), shadowMat);
  shadow.scale.set(1.14, 1.14, 1);
  shadow.position.set(0,-0.01,-0.003);
  group.add(shadow);
  // label
  const tex = textTexture(text, 128, 64, 16, 'center');
  const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
  const label = new THREE.Mesh(new THREE.PlaneGeometry(0.18, 0.06), mat);
  label.position.set(0, -0.13, 0.004);
  group.add(label);
  return group;
  }

  // Arrow: simple triangle
  function createArrow() {
  const shape = new THREE.Shape();
  shape.moveTo(-0.04, -0.02);
  shape.lineTo(0.04, 0);
  shape.lineTo(-0.04, 0.02);
  shape.lineTo(-0.04, -0.02);
  const geo = new THREE.ShapeGeometry(shape);
  // Accent color for arrows
  const mat = new THREE.MeshBasicMaterial({ color:0xffc107, opacity:0.85, transparent:true });
  const mesh = new THREE.Mesh(geo, mat);
  // Drop shadow
  const shadowMat = new THREE.MeshBasicMaterial({ color: 0x000000, opacity: 0.18, transparent: true });
  const shadow = new THREE.Mesh(geo.clone(), shadowMat);
  shadow.position.set(0,-0.01,-0.003);
  mesh.add(shadow);
  return mesh;
  }

  // helper: create a canvas texture with text
  function textTexture(text, width=512, height=128, fontSize=28, align='left') {
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0,0,width,height);
  ctx.font = `${fontSize}px Arial`;
  ctx.fillStyle = '#ff0'; // bright yellow for visibility
  ctx.textAlign = align;
  ctx.textBaseline = 'middle';
  const x = align === 'center' ? width/2 : 12;
  ctx.fillText(text, x, height/2);
  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  return texture;
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  // called when user taps/selects to place panel or interact
  async function onSelect() {
    const session = renderer.xr.getSession();
    if (!session) return;

    // If reticle visible -> place or toggle selection
    if (reticle.visible) {
      // If panel is not yet placed -> create anchor (if possible) and place it
      if (!bpmnPanel.visible) {
        // try to create an anchor from the reticle's matrix
        try {
          // WebXR: if hitTest gave an XRHitTestResult with createAnchor, that would be used.
          // As fallback, create anchor from current transform using XRSession.requestAnimationFrame pose.
          const viewerRefSpace = await session.requestReferenceSpace('local');
          // Try XRAnchor via three.js helper - not standardized in three.js directly, so use session.requestAnchor if available
          if (session.requestAnchor) {
            // Some runtimes provide session.requestAnchor({space: viewerRefSpace}) - optional and experimental.
            // We'll instead attempt to use the hit test createAnchor if available via last frame results
          }
        } catch (err) {
          console.warn('Anchor attempt failed (will place without persistent anchor):', err);
        }

        // place panel at reticle
        bpmnPanel.matrix.copy(reticle.matrix);
        bpmnPanel.matrix.decompose(bpmnPanel.position, bpmnPanel.quaternion, bpmnPanel.scale);
        bpmnPanel.visible = true;
        // slightly offset panel forward so it's comfortably in front of surface
        bpmnPanel.translateZ(0.02);
      } else {
        // panel exists — perform selection test: raycast from controller into panel
        // compute controller world ray
        const controllerGrip = controller;
        const origin = new THREE.Vector3();
        const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(controller.gripped ? controller.gripped.quaternion : controller.quaternion);
        controller.getWorldPosition(origin);
        controller.getWorldQuaternion(tempQuat = new THREE.Quaternion());

        // simpler approach: cast ray from controller forward
        const worldPos = new THREE.Vector3();
        const worldDir = new THREE.Vector3(0, 0, -1);
        controller.getWorldPosition(worldPos);
        controller.getWorldQuaternion(tempQuat = new THREE.Quaternion());
        worldDir.applyQuaternion(tempQuat);

        raycaster.set(worldPos, worldDir);
        // find intersections with panel children (the cards)
        const intersects = raycaster.intersectObjects(bpmnPanel.children, true);
        if (intersects.length) {
          const hit = intersects[0].object;
          // find the node parent if needed
          let node = hit;
          while (node && node.parent !== bpmnPanel) node = node.parent;
          if (node && node.userData && node.userData.label) {
            highlightNode(node);
          }
        }
      }
    }
  }

  function highlightNode(node) {
    // flash the node by scaling and changing opacity slightly
    node.scale.set(1.07, 1.07, 1.07);
    setTimeout(() => node.scale.set(1,1,1), 200);
    console.log('Selected node:', node.userData.label);
    // visual feedback: add small ring behind it
    const ring = new THREE.Mesh(new THREE.RingGeometry(0.065, 0.075, 16).rotateX(Math.PI/2), new THREE.MeshBasicMaterial({ color: 0xffcc00, transparent: true, opacity: 0.9 }));
    ring.position.set(0,0,-0.01);
    node.add(ring);
    setTimeout(() => node.remove(ring), 600);
  }

  // animation loop
  function animate() {
    renderer.setAnimationLoop(render);
  }


  // utilities
  let lastFrame = null;
  async function render(timestamp, xrFrame) {
    // XR frame handling: hit-test & reticle
    const session = renderer.xr.getSession();
    if (session && !hitTestSourceRequested) {
      const viewerSpace = await session.requestReferenceSpace('viewer');
      if (session.requestHitTestSource) {
        session.requestHitTestSource({ space: viewerSpace }).then(source => {
          hitTestSource = source;
        });
      }
      // optional: request anchors support - many runtimes support XRAnchor on hit results via createAnchor()
      session.addEventListener('end', () => {
        hitTestSourceRequested = false;
        hitTestSource = null;
      });
      hitTestSourceRequested = true;
    }

    if (hitTestSource && xrFrame) {
      const referenceSpace = renderer.xr.getReferenceSpace();
      const hitTestResults = xrFrame.getHitTestResults(hitTestSource);
      if (hitTestResults.length > 0) {
        const hit = hitTestResults[0];
        const pose = hit.getPose(referenceSpace);
        if (pose) {
          reticle.visible = true;
          reticle.matrix.fromArray(pose.transform.matrix);
        } else {
          reticle.visible = false;
        }
      } else {
        reticle.visible = false;
      }
    }

    renderer.render(scene, camera);
  }
  </script>
</body>
</html>
